n, W = map(int, input().split())
w = []
v = []
for _ in range(n):
    ww, vv = map(int, input().split())
    w.append(ww)
    v.append(vv)

# dp[i+1][j]=i番目までの品物から重さの総和がj以下となるように選んだ時の価値の総和の最大値
dp = [[0 for j in range(W+1)] for i in range(n+1)]
for i in range(n):
    for j in range(W+1):
    # ナップザックの容量をjと仮定する
        # とi番目の品物を持てないとき
        if j < w[i]:
            # i番目の品物をスルーする
            dp[i + 1][j] = dp[i][j]
        # i番目の品物を持とうと思えば持てるとき
        else:
            # 1.i番目の品物を持たなかった場合
            # 2.i番目の品物を持った場合
            # 以上2通りの内、価値の総和が最大となる品物の選び方をする
            dp[i + 1][j] = max(dp[i][j], dp[i][j - w[i]] + v[i])
print(dp[n][W])


# イメージはこんな感じ
# 入力が
# n = 4
# W = 5
# (w, v) = ((2, 3), (1, 2), (3, 4), (2, 2))
# となるとき
# → はナップザックに入ってる品物の重さ(j <= W)の総和
# ↓ はi(i <= n)番目までの品物を順に確認
# (i+1, j)は最初の品物を0番目として数えたときの、
# i番目までの品物から重さの総和がj以下となるように選んだ時の価値の総和の最大値
# i\j  0   1   2   3   4   5
#
#  0   0   0   0   0   0   0
#
#  1   0   0   3   3   3   3
#
#  2   0   2   3   5   5   5
#
#  3   0   2   3   5   6   7
#
#  4   0   2   3   5   6   7